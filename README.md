# [과제] 

`20194567 컴퓨터공학과 이민제`

## 리눅스 명령어 : top, ps, jobs, kill 알아보자 !

### __0. 들어가기 전 `프로세스 표시 내용`을 간단히 알아보자 !__

|항복|의미|
|:---:|---|
|PID|프로세스의 식별번호|
|USER|프로세스 소유자의 이름|
|PR|프로세스 우선위|
|NI|NICE의 값|
|VIRT|가상 메모리의 사용량|
|RES|현재 페이지가 상주하고 있는 크기|
|SHR|프로세스의 의해 사용된 메모리를 나눈 메모리의 총합|
|S|프로세스의 상태 S: SLEEP R: RUN Z: ZOMBIES(표면상엔 죽었지만 내부엔 계속 살아있는 상태) ,,,|
|%CPU|CPU 사용량|
|%MEM|메모리 사용량|
|COMMAND|실행된 명령어|

---

### 1.  TOP :  **시스템의 상태를 전반적으로 보여주는 명령어**

- top 사용법

    `$ top [option] or $ top`
    
- top 옵션
    |옵션|내용|
    |:---:|---|
    |-b|엔터치는 순간의 정보를 확인|
    |-n|top의 실행 주기|

- top만 입력할 경우 기본적인 시스템의 상태를 나타낸다. (기본 설정인 3초마다 시스템의 상태가 실시간으로 갱신한다)
  
     <img src="https://user-images.githubusercontent.com/104614833/172049824-98f9a33d-db3b-4a3f-96c7-5802a6d2d755.png" widht="490" height="290">
  
- `top -b -n 1` 준다면

     <img src="https://user-images.githubusercontent.com/104614833/172050238-5712be9f-63b8-4b55-a79b-40165efd3e88.png" widht="490" height="290">
     
      : 현재 시간을 기준으로 1초마다 갱신되는 모습을 볼 수 있다. (이미지라 실시간 갱신을 확인하지 못하는 점이 아쉽다)
     
     
---

     
### 2.  PS : **Process Status의 약자로 현재 돌아가고 있는 프로세스를 확인할 수 있는 명령어**
    > top는 프로세스에서 일정 주기로 합산하여 cpu 사용율을 출력하지만 ps는 ps한 시점에서 프로세스에 검색한 cpu 사용량을 보여준다 !

- ps 사용법

    `$ ps [option] or $ ps`

- ps 옵션 `여러가지 있지만 간단히 사용할 수 있는 내용`
    |옵션|내용|
    |:---:|---|
    |-A (대문자)|모든 프로세스를 출력|
    |-f|풀 포맷으로 출력 (UID, PID, PPID 등과 함께 표시된다)|
    |-l|긴 포맷으로 출력 (프로세스의 정보를 길게 보여주며 우선순위와 관련 PRI,NI값을 확인할 수 있다)
    |-p|특정 PID를 지정할 때 사용|
    |-r|현재 실행 중인 프로세서 출력|
    |-u [username] or -u|특정 사용자의 프로세스 정보를 출력, 지정하지 않으면 현재 사용자 기준으로 정보 출력|
    
- ps만 입력할 경우 top와 조금 다른 모습을 볼 수 있다. (기본적인 정보 PID, TTY, TIME, CMD 네 개의 정보 출력)
 
     ![image](https://user-images.githubusercontent.com/104614833/172050762-0b674bca-6014-4d8b-95e0-3821654a7485.png)
     
---    
    
### 3. JOBS : **백드라운드에 실행되고 있는 프로세스나 중지된 프로세스의 목록을 출력해주는 명령어**

- jobs 사용법

    `$ jobs`
    
- jobs를 사용하면 아래와 같은 모습을 볼 수 있다. (현재 리눅스에선 정지되거나 백그라운드가 없어 google에서 실행된 예제를 가져왔다)

     ![image](https://user-images.githubusercontent.com/104614833/172052366-321be4c7-55ca-45a0-b14c-b485ae8c43ec.png)

      - 먼저 맨 앞에 있는 `[1]` 를 볼 수 있는데 이 번호는 job의 번호이다. 나중에 다시 되돌리고 싶다면 이 번호를 이용할 수 있다.

      -  `+, -` 기호를 볼 수 있는 `+` 는 현재 실행되고 있거나 실행예정인 프로세스이고 `-` 는 현재 진행중인 job이 끝나면 바로 다음에 수행될 프로세스를 의미한다.
    
      - 마지막 Stopped 은 job의 상태를 의미한다. ( Running, Done (수행이 롼료된 프로세스 !) ) 
 
---

### 4. KILL : **대개 특정 프로세스를 죽일 때 사용되는 명령어**

- kill 사용법

    `$ kill [option] <pid>`

- kill 옵션 (무수히 많은 옵션이 있지만 대표적인 옵션 2가지 설명)
    |옵션|내용|
    |:---:|---|
    |-9|강제종료|
    |-15|작업종료|
    
- 앞전에 배웠던 ps를 이용하여 프로세스 PID를 확인하여 kill 할 수 있다.

     ![image](https://user-images.githubusercontent.com/104614833/172053035-2f58d3ee-1ede-475c-b986-25e516684eb6.png)



## VIM 에디터에서 매크로 사용법을 알아보자 !

### Vim Macro : **Vim 명령어들을 기록하고, 이를 반복할 수 있는 기능이다.**

- 매크로 사용 방법 (노멀 모드에서)

      1) `q`[레지스터 a-z, 0-9 하나 지정] 로 매크로 시작

        - `q` 로 매크로 종료
 
      2) `@`[지정한 레지스터] 지정된 매크로 실행
      
        - `@@`로 직적에 실행한 매크로 재실행

        - `[반복횟수]@[레지스터]` 또는 `[반복횟수]@@` 로 저장된 매크로를 `반복횟수` 만큼 재실행


 - `q` 기록하기 & 종료하기 / `@`[지정한 레지스터] 실행 !

     ![ezgif-4-7665123eff](https://user-images.githubusercontent.com/104614833/172054425-e07c30bb-cdf8-4f4a-ba7b-160d642b0e24.gif)
     
       - 먼저 `q1`로 매크로 실행

       - `i` (입력모드) 후 `hello [enter]`

       - `esc` 후 `@1` 하여 매크로 실행 

      << 이런식으로 매크로를 사용할 수 있다. >>
